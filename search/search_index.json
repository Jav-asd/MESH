{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Package MESH \u00b6 M ultilayer E lectromagnetic S olver for H eat transfer. A program for computing electromagnetic far-field and near-field heat transfer for periodic, layered structures, developed by Kaifeng Chen ( kfrancischen@gmail.com ) of the Fan group in the Stanford Electrical Engineering Department. The program is built upon C++ and wrapped with Lua (>= 5.2) and Python (both 2 and 3), with OpenMP and MPI support. It is enabled with heat flux calculation in both far and near field for planar, grating and pattern geometries. The source code can be downloaded at Github . This document will cover the basic ideas behind MESH, complete descriptions of the Lua API and C++ API, and a few concrete examples created either to illustrate the simple usage or to reproduce some of results from existing literatures. The documents are organized as follows: Overview \u00b6 Equations & Features : detailed equations computed and features offered by the package. Installation : the installation steps on different platforms and clusters. Lua API \u00b6 Base Class : the base class the code is built upon. SimulationPlanar : the inherited class for planar geometries. SimulationGrating : the inherited class for 1D grating geometries. SimulationPattern : the inherited class for 2D pattern geometries. Python API \u00b6 Base Class : the base class the code is built upon. SimulationPlanar : the inherited class for planar geometries. SimulationGrating : the inherited class for 1D grating geometries. SimulationPattern : the inherited class for 2D pattern geometries. C++ API \u00b6 C++ classes and functions : the C++ interface for all the functions. Examples \u00b6 Tutorial Example : a simple tutorial about setting up the inputs and running the input script. Single Plane Far-field : example about thermal radiation to the far field. Two Planes Near-field : example about near-field heat transfer between two planes. Anisotropic Material Near-field : example about simulations involving anisotropic material. Iterate Over Gaps Near-field : example about iterating over different gaps for near-field heat transfer between two plates. Two Gratings Near-field : example the calculation between two grating structures in the near-field regime. Two Rectangle Patterns Near-field : example about the near-field heat transfer between two rectangle patterned structures. Mixed Patterns Near-field : example about the near-field heat transfer between two structures with different kinds of patterns (rectangle and circle). Contained Patterns Near-field : example about the near-field heat transfer between two structures with two contained circles that result in a cylindrical shell. MPI Example : example about how to use Lua wrapped MPI interface for fast parallelization on distributed clusters. Other information \u00b6 Developer : information for developers on how to contribute to MESH. About : information about the author, license, copyrights and contact addresses.","title":"Home"},{"location":"#package-mesh","text":"M ultilayer E lectromagnetic S olver for H eat transfer. A program for computing electromagnetic far-field and near-field heat transfer for periodic, layered structures, developed by Kaifeng Chen ( kfrancischen@gmail.com ) of the Fan group in the Stanford Electrical Engineering Department. The program is built upon C++ and wrapped with Lua (>= 5.2) and Python (both 2 and 3), with OpenMP and MPI support. It is enabled with heat flux calculation in both far and near field for planar, grating and pattern geometries. The source code can be downloaded at Github . This document will cover the basic ideas behind MESH, complete descriptions of the Lua API and C++ API, and a few concrete examples created either to illustrate the simple usage or to reproduce some of results from existing literatures. The documents are organized as follows:","title":"Package MESH"},{"location":"#overview","text":"Equations & Features : detailed equations computed and features offered by the package. Installation : the installation steps on different platforms and clusters.","title":"Overview"},{"location":"#lua-api","text":"Base Class : the base class the code is built upon. SimulationPlanar : the inherited class for planar geometries. SimulationGrating : the inherited class for 1D grating geometries. SimulationPattern : the inherited class for 2D pattern geometries.","title":"Lua API"},{"location":"#python-api","text":"Base Class : the base class the code is built upon. SimulationPlanar : the inherited class for planar geometries. SimulationGrating : the inherited class for 1D grating geometries. SimulationPattern : the inherited class for 2D pattern geometries.","title":"Python API"},{"location":"#c-api","text":"C++ classes and functions : the C++ interface for all the functions.","title":"C++ API"},{"location":"#examples","text":"Tutorial Example : a simple tutorial about setting up the inputs and running the input script. Single Plane Far-field : example about thermal radiation to the far field. Two Planes Near-field : example about near-field heat transfer between two planes. Anisotropic Material Near-field : example about simulations involving anisotropic material. Iterate Over Gaps Near-field : example about iterating over different gaps for near-field heat transfer between two plates. Two Gratings Near-field : example the calculation between two grating structures in the near-field regime. Two Rectangle Patterns Near-field : example about the near-field heat transfer between two rectangle patterned structures. Mixed Patterns Near-field : example about the near-field heat transfer between two structures with different kinds of patterns (rectangle and circle). Contained Patterns Near-field : example about the near-field heat transfer between two structures with two contained circles that result in a cylindrical shell. MPI Example : example about how to use Lua wrapped MPI interface for fast parallelization on distributed clusters.","title":"Examples"},{"location":"#other-information","text":"Developer : information for developers on how to contribute to MESH. About : information about the author, license, copyrights and contact addresses.","title":"Other information"},{"location":"about/","text":"MESH is copyright (c) 2016-2018, Stanford University. MESH is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. You can also find it on the GNU web site: http://www.gnu.org/copyleft/gpl.html The author would like to acknowledge the following packages: armadillo: C++ linear algebra library luawrapper: The lua wrapper for C++ classes lua-mpi: The lua wrapper for MPI Also, the author would like to thank Dr. Bo Zhao , Yu Guo and alumni Dr. Linxiao Zhu , Dr. Victor Liu for useful discussions, and Siddharth Buddhiraju for testing installation and some cases.","title":"About"},{"location":"develop/","text":"The source code of MESH is in src/ folder, which consists of the following files and folders: arma/ : the folder contains all the headers from armadillo . luawrapper/ : the Lua wrapper for C++ classes and MPI. mathlib/ : some mathematical functions such as Bessel functions, and Gauss-legendre integral method. utility/ : templates for smart points as well as exception handling. Cubature.c : a fast adaptive integration method for high dimensional functions, adoptted from the original code . Fmm.cpp : file computing the Fourier transform for different geometries. Gsel.cpp : file containing functions to select G vectors. Rcwa.cpp : file computing the RCWA and Poynting vector. System.cpp : file containing material, layer and structure classes and their methods. Mesh.cpp : file containing different types of simulations and C++ API. main_lua.cpp : file implementing Lua API. main_python.cpp : file implementing Python API. The class structure is illustrated in the following figure There are few features that need to be implemented in MESH: A correct and fast implementation of Fourier transform over dielectric functions. Improved ways of doing k_x and k_y integral other than the current naive summation method. Computing more physical quantities, such as energy density and Casimir force.","title":"Developer"},{"location":"features/","text":"Physical Quantities Computed By MESH \u00b6 By classifying the geometries into three different categories: planar geometry where the basic components are plates, grating geometry which contains at least one layer has a grating along x direction, and patterns where at least one layer has either rectangle or circular patterns. The details about these three types are discussed below. In general, the total heat transfer between bodies with temperatures T_1 and T_2 is written as P=\\int d\\omega [\\Theta(T_1, \\omega)-\\Theta(T_2,\\omega)]\\Phi(\\omega) where the quantity \\Phi(\\omega) characterize the strength of heat transfer between the two bodies involved. Heat transfer in planar geometries \u00b6 For planar geometries (implemented as SimulationPlanar object), the quantity \\Phi(\\omega) computed by integrating the k_x and k_y vector over the whole k space, i.e. \\Phi(\\omega)=\\int_{-\\infty}^{\\infty}dk_x\\int_{-\\infty}^{\\infty}dk_y \\Phi(k_x,k_y, \\omega) And in the case of an isotropic material in x and y direction, the above integral can be reduced to \\Phi(\\omega)=\\int_{0}^{\\infty}dk_{\\parallel} \\Phi(k_{\\parallel}, \\omega) MESH directly provides functions to compute \\Phi(\\omega, k_x, k_y) , \\Phi(\\omega, k_{\\parallel}) and \\Phi(\\omega) directly. Heat transfer in grating geometries \u00b6 In the case of a grating geometry (implemented as SimulationGrating object), the heat transfer rate is written as \\Phi(\\omega)=\\int_{-G_1/2}^{G_1/2}dk_x\\int_{-\\infty}^{\\infty}dk_y \\Phi(k_x,k_y, \\omega) Here again, MESH gives access to a few things settings of the integral: for isotropic geometries \\int_{-G_x/2}^{G_x/2} and \\int_{-\\infty}^{\\infty} can be reduced to twice of the integral over the positive axis. directly computation of \\Phi(k_x,k_y, \\omega) and \\Phi(\\omega) , and allows to print out \\Phi(k_x,k_y, \\omega) in the process of obtaining \\Phi(\\omega) . Heat transfer in pattern geometries \u00b6 In the case of a pattern geometry (implemented as SimulationPattern object), the heat transfer rate is written as \\Phi(\\omega)=\\int\\int_{first BZ}dk_xdk_y \\Phi(k_x,k_y, \\omega) Again similar to the grating geometries, integral settings and printing of intermediate \\Phi(k_x,k_y, \\omega) are supported. In addition, multiple different kinds of patterns can exist in one layer. However, the code now only supports a rectangle lattice. In MESH, for 2D patterns the supported types of patterns supported are rectangle, circle, ellipse and polygon, and each pattern cannot partially overlap with each other. But one pattern can be fully contained inside another pattern. In addition, extending the code to non-trivial lattice and adding supports to more patterns are in principle doable. Supports over both scalar dielectric and tensor dielectric \u00b6 MESH also supports material whose dielectric can be scalar, diagonal, or a tensor. These three different types are encapsulated into a Union type in MESH. Currently for tensor types, MESH can only deal with the case when epsilon in the z direction can be decomposed from x and y directions, i.e. \\overleftrightarrow{\\epsilon}=\\begin{pmatrix} \\epsilon_{xx} & \\epsilon_{xy} & 0\\\\ \\epsilon_{yx} & \\epsilon_{yy} & 0\\\\ 0 & 0 & \\epsilon_{zz} \\end{pmatrix} A Comprehensive Lua Wrapper for Users \u00b6 Lua wrapper for C code is widely used because of easy implementation and high readability. For example, S4 which is also an implementation of RCWA for periodic geometries, also utilizes Lua as its front. Here MESH not only gives the user basic functionalities of computing physical quantities related to heat transfer, but also allows users to directly use MPI in a lua script, so that users have better control over the simulation at run time. To show the advantages of directly revealing MPI interface to the users, a concrete example of lua MPI interface is explained in the example section . MESH also provides a vanilla version that can be built without MPI. In that case, OpenMP is used if the system has OpenMP libraries built in.","title":"Equations & Features"},{"location":"features/#physical-quantities-computed-by-mesh","text":"By classifying the geometries into three different categories: planar geometry where the basic components are plates, grating geometry which contains at least one layer has a grating along x direction, and patterns where at least one layer has either rectangle or circular patterns. The details about these three types are discussed below. In general, the total heat transfer between bodies with temperatures T_1 and T_2 is written as P=\\int d\\omega [\\Theta(T_1, \\omega)-\\Theta(T_2,\\omega)]\\Phi(\\omega) where the quantity \\Phi(\\omega) characterize the strength of heat transfer between the two bodies involved.","title":"Physical Quantities Computed By MESH"},{"location":"features/#heat-transfer-in-planar-geometries","text":"For planar geometries (implemented as SimulationPlanar object), the quantity \\Phi(\\omega) computed by integrating the k_x and k_y vector over the whole k space, i.e. \\Phi(\\omega)=\\int_{-\\infty}^{\\infty}dk_x\\int_{-\\infty}^{\\infty}dk_y \\Phi(k_x,k_y, \\omega) And in the case of an isotropic material in x and y direction, the above integral can be reduced to \\Phi(\\omega)=\\int_{0}^{\\infty}dk_{\\parallel} \\Phi(k_{\\parallel}, \\omega) MESH directly provides functions to compute \\Phi(\\omega, k_x, k_y) , \\Phi(\\omega, k_{\\parallel}) and \\Phi(\\omega) directly.","title":"Heat transfer in planar geometries"},{"location":"features/#heat-transfer-in-grating-geometries","text":"In the case of a grating geometry (implemented as SimulationGrating object), the heat transfer rate is written as \\Phi(\\omega)=\\int_{-G_1/2}^{G_1/2}dk_x\\int_{-\\infty}^{\\infty}dk_y \\Phi(k_x,k_y, \\omega) Here again, MESH gives access to a few things settings of the integral: for isotropic geometries \\int_{-G_x/2}^{G_x/2} and \\int_{-\\infty}^{\\infty} can be reduced to twice of the integral over the positive axis. directly computation of \\Phi(k_x,k_y, \\omega) and \\Phi(\\omega) , and allows to print out \\Phi(k_x,k_y, \\omega) in the process of obtaining \\Phi(\\omega) .","title":"Heat transfer in grating geometries"},{"location":"features/#heat-transfer-in-pattern-geometries","text":"In the case of a pattern geometry (implemented as SimulationPattern object), the heat transfer rate is written as \\Phi(\\omega)=\\int\\int_{first BZ}dk_xdk_y \\Phi(k_x,k_y, \\omega) Again similar to the grating geometries, integral settings and printing of intermediate \\Phi(k_x,k_y, \\omega) are supported. In addition, multiple different kinds of patterns can exist in one layer. However, the code now only supports a rectangle lattice. In MESH, for 2D patterns the supported types of patterns supported are rectangle, circle, ellipse and polygon, and each pattern cannot partially overlap with each other. But one pattern can be fully contained inside another pattern. In addition, extending the code to non-trivial lattice and adding supports to more patterns are in principle doable.","title":"Heat transfer in pattern geometries"},{"location":"features/#supports-over-both-scalar-dielectric-and-tensor-dielectric","text":"MESH also supports material whose dielectric can be scalar, diagonal, or a tensor. These three different types are encapsulated into a Union type in MESH. Currently for tensor types, MESH can only deal with the case when epsilon in the z direction can be decomposed from x and y directions, i.e. \\overleftrightarrow{\\epsilon}=\\begin{pmatrix} \\epsilon_{xx} & \\epsilon_{xy} & 0\\\\ \\epsilon_{yx} & \\epsilon_{yy} & 0\\\\ 0 & 0 & \\epsilon_{zz} \\end{pmatrix}","title":"Supports over both scalar dielectric and tensor dielectric"},{"location":"features/#a-comprehensive-lua-wrapper-for-users","text":"Lua wrapper for C code is widely used because of easy implementation and high readability. For example, S4 which is also an implementation of RCWA for periodic geometries, also utilizes Lua as its front. Here MESH not only gives the user basic functionalities of computing physical quantities related to heat transfer, but also allows users to directly use MPI in a lua script, so that users have better control over the simulation at run time. To show the advantages of directly revealing MPI interface to the users, a concrete example of lua MPI interface is explained in the example section . MESH also provides a vanilla version that can be built without MPI. In that case, OpenMP is used if the system has OpenMP libraries built in.","title":"A Comprehensive Lua Wrapper for Users"},{"location":"installation/","text":"Prerequisites \u00b6 MESH comes with two versions: one has OpenMP support if the system has OpenMP libraries; one has MPI support. Both of them require the following prerequisites: Lapack and blas (or blas mutants, such as openblas , atlas , or mkl ). For MacOS this is not necessary. Lua (optional) version >= 5.2 (version 5.3.x is preferred). Required for Lua versions of MESH. Python (optional) currently only Python 2 is supported. In order to have the MPI version of MESH installed, one needs to install MPI besides the above two libraries. MESH can be downloaded by git clone git@github.com:kfrancischen/MESH.git cd MESH Below are the instructions on install the Lua version: Installation on Linux \u00b6 installation of CPP openmp version (no Lua required) \u00b6 The CPP-only version can be installed by make -f Makefile.without_lua This command line will generate static MESH library called libmesh.a in build/ folder, and can be used to compile along with C code. installation of Lua vanilla version (no MPI required) \u00b6 If the above libraries are installed on the system default directory, The vanilla version of MESH can be simply installed by make mesh Installing this version does not require MPI packages. The executable can be found in directory build/ . The executable is called mesh . installation of Lua MPI version (MPI required) \u00b6 The MPI version can be installed by make meshMPI The executables can be found in directory build/ . The executable is called meshMPI . For a customized installation, please change the paths for compilers in Makefile.Linux . For OpenMP support, one can add (replace 4 with the maximum number of cores supported by the computer) export OMP_NUM_THREADS = 4 to the .bashrc file. installation of Python version (Python required) \u00b6 To Install Python version, please modify gensetup.py.sh , and then make meshPy Installation on MacOS \u00b6 Default clang compiler does not support OpenMP. One can either follow the same steps exactly the same as the installation on Linux machines (then no OpenMP is not supported), or installing gcc with OpenMP first by brew install gcc --without-multilib and then change the compiles from cc and c++ in Makefile.Darwin to corresponding GNU compilers, and add -fopenmp in the CFLAGS and CXXFLAGS . The installation options are exactly the same as the installation on Linux. Installation on Windows \u00b6 The easiest way to install mesh on windows is to download Ubuntu on Windows and follow the instructions in the Linux installation part. With Ubuntu on Windows , one can do sudo apt get for the required packages. Location on Clusters \u00b6 The mesh has been built on hera , comet and stampede . The executables are in the directory /home/kfchen/MESH/build/ One can add this to one's own path by adding export PATH = \" $PATH :/home/kfchen/MESH/build/\" in .bashrc (on stampede it is .profile for bash ). In addition, on hera , please add the following line to .bashrc export LD_LIBRARY_PATH = \"LD_LIBRARY_PATH:/home/kfchen/mkl/mkl/lib/intel64\" On comet , please add the following to your job submission file module purge module load gnu module load gnutools module load mkl module load openmpi_ib and on stampede : module purge module load gcc module load mvapich2 module load mkl For a job that use more than 24 cores for comet and 16 cores for stampede , MPI version should be used. On hera , the OpenMP version is recommended. (Update for stampede2 , 09/27/2017): For stampede2 please change module load mvapich2 to module load impi Installation on clusters (not recommended) \u00b6 If one wants to install MESH on his/her own directory, one hera please use make -f Makefile.hera On comet please install Lua at the same directory as MESH and type module purge module load gnu module load gnutools module load mkl module load openmpi_ib make -f Makefile.comet On stampede please install Lua at the same directory as MESH and type module purge module load gcc module load mvapich2 module load mkl make -f Makefile.stampede On clusters, both OpenMP version and MPI version will be generated. Currently the Python version hasn't been tested on comet and stampede . For Python MPI support, one needs mpi4py","title":"Installation"},{"location":"installation/#prerequisites","text":"MESH comes with two versions: one has OpenMP support if the system has OpenMP libraries; one has MPI support. Both of them require the following prerequisites: Lapack and blas (or blas mutants, such as openblas , atlas , or mkl ). For MacOS this is not necessary. Lua (optional) version >= 5.2 (version 5.3.x is preferred). Required for Lua versions of MESH. Python (optional) currently only Python 2 is supported. In order to have the MPI version of MESH installed, one needs to install MPI besides the above two libraries. MESH can be downloaded by git clone git@github.com:kfrancischen/MESH.git cd MESH Below are the instructions on install the Lua version:","title":"Prerequisites"},{"location":"installation/#installation-on-linux","text":"","title":"Installation on Linux"},{"location":"installation/#installation-of-cpp-openmp-version-no-lua-required","text":"The CPP-only version can be installed by make -f Makefile.without_lua This command line will generate static MESH library called libmesh.a in build/ folder, and can be used to compile along with C code.","title":"installation of CPP openmp version (no Lua required)"},{"location":"installation/#installation-of-lua-vanilla-version-no-mpi-required","text":"If the above libraries are installed on the system default directory, The vanilla version of MESH can be simply installed by make mesh Installing this version does not require MPI packages. The executable can be found in directory build/ . The executable is called mesh .","title":"installation of Lua vanilla version (no MPI required)"},{"location":"installation/#installation-of-lua-mpi-version-mpi-required","text":"The MPI version can be installed by make meshMPI The executables can be found in directory build/ . The executable is called meshMPI . For a customized installation, please change the paths for compilers in Makefile.Linux . For OpenMP support, one can add (replace 4 with the maximum number of cores supported by the computer) export OMP_NUM_THREADS = 4 to the .bashrc file.","title":"installation of Lua MPI version (MPI required)"},{"location":"installation/#installation-of-python-version-python-required","text":"To Install Python version, please modify gensetup.py.sh , and then make meshPy","title":"installation of Python version (Python required)"},{"location":"installation/#installation-on-macos","text":"Default clang compiler does not support OpenMP. One can either follow the same steps exactly the same as the installation on Linux machines (then no OpenMP is not supported), or installing gcc with OpenMP first by brew install gcc --without-multilib and then change the compiles from cc and c++ in Makefile.Darwin to corresponding GNU compilers, and add -fopenmp in the CFLAGS and CXXFLAGS . The installation options are exactly the same as the installation on Linux.","title":"Installation on MacOS"},{"location":"installation/#installation-on-windows","text":"The easiest way to install mesh on windows is to download Ubuntu on Windows and follow the instructions in the Linux installation part. With Ubuntu on Windows , one can do sudo apt get for the required packages.","title":"Installation on Windows"},{"location":"installation/#location-on-clusters","text":"The mesh has been built on hera , comet and stampede . The executables are in the directory /home/kfchen/MESH/build/ One can add this to one's own path by adding export PATH = \" $PATH :/home/kfchen/MESH/build/\" in .bashrc (on stampede it is .profile for bash ). In addition, on hera , please add the following line to .bashrc export LD_LIBRARY_PATH = \"LD_LIBRARY_PATH:/home/kfchen/mkl/mkl/lib/intel64\" On comet , please add the following to your job submission file module purge module load gnu module load gnutools module load mkl module load openmpi_ib and on stampede : module purge module load gcc module load mvapich2 module load mkl For a job that use more than 24 cores for comet and 16 cores for stampede , MPI version should be used. On hera , the OpenMP version is recommended. (Update for stampede2 , 09/27/2017): For stampede2 please change module load mvapich2 to module load impi","title":"Location on Clusters"},{"location":"installation/#installation-on-clusters-not-recommended","text":"If one wants to install MESH on his/her own directory, one hera please use make -f Makefile.hera On comet please install Lua at the same directory as MESH and type module purge module load gnu module load gnutools module load mkl module load openmpi_ib make -f Makefile.comet On stampede please install Lua at the same directory as MESH and type module purge module load gcc module load mvapich2 module load mkl make -f Makefile.stampede On clusters, both OpenMP version and MPI version will be generated. Currently the Python version hasn't been tested on comet and stampede . For Python MPI support, one needs mpi4py","title":"Installation on clusters (not recommended)"},{"location":"C++API/classAndFunction/","text":"The C++ interface have the same functions as the Lua interface except for the following changes. An instance of a class is initiated to smart pointers. For example to instantiate a SimulationPlanar object, the right way to do is Ptr < SimulationPlanar > s = SimulationPlanar :: instanceNew (); This also applies to the instantiation of SimulationGrating and SimulationPattern objects. The advantage of using smart pointers is that there is no need to do manual gabage collection using delete . Function names: the function names starts with lower case whereas Lua interface starts with a capital letter. extra inputs in function setMaterial . In C++, this function is called as void setMaterial ( const std :: string name , double ** epsilon , const std :: string type ) where type is one of \"scalar\", \"diagonal\" and \"tensor\". The 2D array epsilon then depends on the type. For scalar, the epsilon is of dimension \\text{# omega}\\times 2 . For diagonal, the epsilon is of dimension \\text{# omega}\\times 6 , and for tensor, the epsilon is of dimension \\text{# omega}\\times 10 . changes in obtaining physical constants. In C++ there is no need to initiate or call any function to retrieve the constants. A constant, for example q , can be directly obtained by using constant.q. Extra Makefile is needed. An example for the Makefile for a main.cpp file is CFLAGS = -std = c++11 -O3 -ffast-math -march = native -fopenmp MESHPATH = ../../ INCLUDES = -I $( MESHPATH ) /src ARMAINCLUDE = -I $( MESHPATH ) /src/arma -DARMA_DONT_USE_WRAPPER -DARMA_NO_DEBUG LIBS = -L $( MESHPATH ) /build -lmesh -lopenblas -llapack CXX = g++ all: $( CXX ) $( CFLAGS ) $( INCLUDES ) ${ ARMAINCLUDE } main.cpp -o main $( LIBS ) The MESHPATH should point to where the src folder is placed.","title":"Classes and Functions"},{"location":"Examples/MPI/","text":"This is an MPI example, rewriting the same example in Two Gratings Near-field s = SimulationGrating . new (); s : SetLattice ( 1e-6 ); s : AddMaterial ( \"Au\" , \"fullGold.txt\" ); s : AddMaterial ( \"Vacuum\" , \"fullVacuum.txt\" ); s : AddLayer ( \"BottomAir\" , 0 , \"Vacuum\" ); s : AddLayer ( \"GoldSubstrateBottom\" , 0.5e-6 , \"Au\" ); s : AddLayer ( \"GoldGratingBottom\" , 5e-6 , \"Au\" ); s : SetLayerPatternGrating ( \"GoldGratingBottom\" , \"Vacuum\" , 0.5e-6 , 0.2e-6 ); s : AddLayer ( \"VacGap\" , 1e-6 , \"Vacuum\" ); s : AddLayerCopy ( \"GoldGratingTop\" , \"GoldGratingBottom\" ); s : AddLayerCopy ( \"GoldSubstrateTop\" , \"GoldSubstrateBottom\" ); s : AddLayerCopy ( \"TopAir\" , \"BottomAir\" ); s : SetSourceLayer ( \"GoldSubstrateBottom\" ); s : SetSourceLayer ( \"GoldGratingBottom\" ); s : SetProbeLayer ( \"VacGap\" ); s : OptPrintIntermediate (); s : SetNumOfG ( 101 ); s : SetKxIntegralSym ( 500 ); s : SetKyIntegralSym ( 200 , 5 ); s : InitSimulation (); The above are the same as the standard Lua script. The following code configures the MPI. ---------------------------------------------------------------- -- this part is for MPI -- in principle there is no need to change this part for your simulation ---------------------------------------------------------------- -- start MPI local sizeb = buffer . new_buffer ( buffer . sizeof ( buffer . int )) local rankb = buffer . new_buffer ( buffer . sizeof ( buffer . int )) MPI . Init () MPI . Comm_rank ( MPI . COMM_WORLD , rankb ) MPI . Comm_size ( MPI . COMM_WORLD , sizeb ) local size = buffer . get_typed ( sizeb , buffer . int , 0 ) local rank = buffer . get_typed ( rankb , buffer . int , 0 ) if rank == 0 then s : OutputSysInfo (); end status = MPI . Status () numOfOmega = s : GetNumOfOmega () omega = s : GetOmega (); -- rank 0 is the master node if rank == 0 then s : IntegrateKxKyMPI ( rank , size ); phi_master = s : GetPhi (); -- master collects values from slave for i = 1 , size - 1 do local phi_local = buffer . new_buffer ( numOfOmega * buffer . sizeof ( buffer . double )); MPI . Recv ( phi_local , numOfOmega , MPI . DOUBLE , i , 0 , MPI . COMM_WORLD , status ); for j = 1 , numOfOmega do phi_master [ j ] = phi_master [ j ] + buffer . get_typed ( phi_local , buffer . double , j - 1 ); end end -- output all the phi values from the master for i = 1 , numOfOmega do print ( string.format ( \"%e\" , omega [ i ]) .. \" \\t \" .. string.format ( \"%e\" , phi_master [ i ])); end -- rank 1-size are the slave nodes else s : IntegrateKxKyMPI ( rank , size ); local phi_slave = s : GetPhi (); -- slave nodes send phi values back to master local phi_ = buffer . new_buffer ( numOfOmega * buffer . sizeof ( buffer . double )); for i = 1 , numOfOmega do buffer . set_typed ( phi_ , buffer . double , i - 1 , phi_slave [ i ]); end MPI . Send ( phi_ , numOfOmega , MPI . DOUBLE , 0 , 0 , MPI . COMM_WORLD ); end MPI . Finalize (); The above code uses master-slave manner, where rank 0 is the master node that collects all the \\Phi(\\omega) from the other slave nodes, and then sum them together. The code can be run by: mpirun -np 40 meshMPI main.lua The corresponding Python MPI version is from MESH import SimulationGrating s = SimulationGrating () s . SetLattice ( 1e-6 ) s . AddMaterial ( \"Au\" , \"fullGold.txt\" ) s . AddMaterial ( \"Vacuum\" , \"fullVacuum.txt\" ) s . AddLayer ( \"BottomAir\" , 0 , \"Vacuum\" ) s . AddLayer ( \"GoldSubstrateBottom\" , 0.5e-6 , \"Au\" ) s . AddLayer ( \"GoldGratingBottom\" , 5e-6 , \"Au\" ) s . SetLayerPatternGrating ( \"GoldGratingBottom\" , \"Vacuum\" , 0.5e-6 , 0.2e-6 ) s . AddLayer ( \"VacGap\" , 1e-6 , \"Vacuum\" ) s . AddLayerCopy ( \"GoldGratingTop\" , \"GoldGratingBottom\" ) s . AddLayerCopy ( \"GoldSubstrateTop\" , \"GoldSubstrateBottom\" ) s . AddLayerCopy ( \"TopAir\" , \"BottomAir\" ) s . SetSourceLayer ( \"GoldSubstrateBottom\" ) s . SetSourceLayer ( \"GoldGratingBottom\" ) s . SetProbeLayer ( \"VacGap\" ) s . OptPrintIntermediate () s . SetNumOfG ( 50 ) s . SetKxIntegralSym ( 2 ) s . SetKyIntegralSym ( 2 , 5 ) s . InitSimulation () \"\"\" -- this part is for MPI -- in principle there is no need to change this part for your simulation \"\"\" from mpi4py import MPI comm = MPI . COMM_WORLD size = comm . Get_size () rank = comm . Get_rank () if rank == 0 : s . OutputSysInfo () numOfOmega = s . GetNumOfOmega () if rank == 0 : s . IntegrateKxKyMPI ( rank , size ); phi_master = s . GetPhi () phi = list ( phi_master ) for i in range ( 1 , size ): phi_slave = comm . recv ( source = i , tag = 11 ) for j in range ( numOfOmega ): phi [ j ] = phi [ j ] + phi_slave [ j ] for i in range ( numOfOmega ): print phi [ i ] else : s . IntegrateKxKyMPI ( rank , size ) phi_slave = s . GetPhi () comm . send ( phi_slave , dest = 0 , tag = 11 ) The code can be run by: mpirun -np 40 Python main.py","title":"MPI Example"},{"location":"Examples/anisotropic/","text":"This is an example that has been used in the paper Phys. Rev. Applied 6, 024014, 2016 , where hBN has a diagonal dielectric function as (top 5 rows) 2.127000e+14 1.022020e+01 3.983602e-01 1.022020e+01 3.983602e-01 4.251609e+00 3.151862e-01 2.128640e+14 1.023858e+01 3.932224e-01 1.023858e+01 3.932224e-01 4.248610e+00 3.151862e-01 2.130281e+14 1.025696e+01 3.880846e-01 1.025696e+01 3.880846e-01 4.253492e+00 3.151862e-01 2.131921e+14 1.027534e+01 3.829468e-01 1.027534e+01 3.829468e-01 4.258538e+00 3.151862e-01 2.133561e+14 1.029372e+01 3.778090e-01 1.029372e+01 3.778090e-01 4.263583e+00 3.151862e-01 These values correspond to \\omega, \\text{real}(\\epsilon_{xx}), \\text{imag}(\\epsilon_{xx}), \\text{real}(\\epsilon_{yy}), \\text{imag}(\\epsilon_{yy}), \\text{real}(\\epsilon_{zz}), \\text{imag}(\\epsilon_{zz}) , respectively. And the following is a script computing the flux between MCT and hBN in the presence of a 10~\\text{nm} vacuum gap. s = SimulationPlanar . new () s : AddMaterial ( \"hBN\" , \"hBN.txt\" ) s : AddMaterial ( \"MCT\" , \"MCT.txt\" ) s : AddMaterial ( \"PEC\" , \"PEC.txt\" ) s : AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ) s : AddLayer ( \"PECBottom\" , 0 , \"PEC\" ); s : AddLayer ( \"hBNLayer\" , 5e-6 , \"hBN\" ); s : AddLayer ( \"VacLayer\" , 1e-8 , \"Vacuum\" ); s : AddLayer ( \"MCTLayer\" , 5e-6 , \"MCT\" ); s : AddLayerCopy ( \"PECTop\" , \"PECBottom\" ); s : SetSourceLayer ( \"hBNLayer\" ); s : SetProbeLayer ( \"VacLayer\" ); s : SetKParallelIntegral ( 100 ); s : SetThread ( 4 ); s : OptUseQuadgk (); s : InitSimulation (); s : IntegrateKParallel (); phi = s : GetPhi (); omega = s : GetOmega (); for i = 1 , s : GetNumOfOmega (), 1 do print ( string.format ( \"%e\" , omega [ i ]) .. \" \\t \" .. string.format ( \"%e\" , phi [ i ])); end The output of the Lua file is the same as the output from the original MATLAB code. The output from the MATLAB code is Electron_5000_10_5000.mat . The corresponding Python script is from MESH import SimulationPlanar s = SimulationPlanar () s . AddMaterial ( \"hBN\" , \"hBN.txt\" ) s . AddMaterial ( \"MCT\" , \"MCT.txt\" ) s . AddMaterial ( \"PEC\" , \"PEC.txt\" ) s . AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ) s . AddLayer ( \"PECBottom\" , 0 , \"PEC\" ); s . AddLayer ( \"hBNLayer\" , 5e-6 , \"hBN\" ); s . AddLayer ( \"VacLayer\" , 1e-8 , \"Vacuum\" ); s . AddLayer ( \"MCTLayer\" , 5e-6 , \"MCT\" ); s . AddLayerCopy ( \"PECTop\" , \"PECBottom\" ); s . SetSourceLayer ( \"hBNLayer\" ); s . SetProbeLayer ( \"VacLayer\" ); s . SetKParallelIntegral ( 100 ); s . SetThread ( 4 ); s . OptUseQuadgk (); s . InitSimulation (); s . IntegrateKParallel (); phi = s . GetPhi () omega = s . GetOmega () for i in range ( s . GetNumOfOmega ()): print omega [ i ], ' \\t ' , phi [ i ]","title":"Anisotropic Material Near-field"},{"location":"Examples/containedPattern/","text":"The following example creates two contained circle patterns in the layer of SiBottom , resulting in a cylindrical shell made of vacuum. s = SimulationPattern . new (); s : SetLattice ( 1e-7 , 1e-7 , 90 ); s : SetNumOfG ( 250 ); --s:OptSetLatticeTruncation(\"Parallelogramic\") s : AddMaterial ( \"Si\" , \"Si.txt\" ); s : AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ); s : AddLayer ( \"SiBottom\" , 0 , \"Si\" ); s : SetLayerPatternCircle ( \"SiBottom\" , \"Vacuum\" , { 50e-9 , 50e-9 }, 45e-9 ) s : SetLayerPatternCircle ( \"SiBottom\" , \"Si\" , { 50e-9 , 50e-9 }, 30e-9 ) s : AddLayer ( \"VacGap\" , 1e-7 , \"Vacuum\" ); s : AddLayer ( \"SiTop\" , 0 , \"Si\" ); s : SetSourceLayer ( \"SiBottom\" ); s : SetProbeLayer ( \"VacGap\" ); s : OptPrintIntermediate (); s : SetKxIntegralSym ( 100 ); s : SetKyIntegralSym ( 100 ); s : InitSimulation (); s : OutputSysInfo (); s : IntegrateKxKy (); The output from the function GetLayerPatternRealization results in the following figure The resulting \\Phi(\\omega) is The corresponding Python version is from MESH import SimulationPattern s = SimulationPattern () s . SetLattice ( 1e-6 , 1e-6 , 90 ) s . SetNumOfG ( 440 ) s . AddMaterial ( \"Si\" , \"Si.txt\" ) s . AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ) s . AddLayer ( \"SiBottom\" , 0 , \"Si\" ) s . AddLayer ( \"VacGap\" , 1e-6 , \"Vacuum\" ) s . AddLayer ( \"SiTop\" , 0 , \"Si\" ) s . SetLayerPatternRectangle ( \"SiTop\" , \"Vacuum\" , ( 2.5e-7 , 2.5e-7 ), 0 , ( 5e-7 , 5e-7 )) s . SetLayerPatternCircle ( \"SiTop\" , \"Vacuum\" , ( 7.5e-7 , 7.5e-7 ), 2.5e-7 ) s . SetSourceLayer ( \"SiBottom\" ) s . SetProbeLayer ( \"VacGap\" ) s . OutputSysInfo () s . OptPrintIntermediate () s . SetKxIntegralSym ( 20 , 60 ) s . SetKyIntegralSym ( 20 , 60 ) s . InitSimulation () s . IntegrateKxKy ()","title":"Contained Patterns Near-field"},{"location":"Examples/gratingNearField/","text":"This code can produce the result in Fig. 3 (a) red curve in Phys. Rev. B 93, 155403, 2016 . s = SimulationGrating . new () s : SetLattice ( 1e-6 ); s : AddMaterial ( \"Au\" , \"fullGold.txt\" ); s : AddMaterial ( \"Vacuum\" , \"fullVacuum.txt\" ); s : AddLayer ( \"BottomAir\" , 0 , \"Vacuum\" ); s : AddLayer ( \"GoldSubstrateBottom\" , 0.5e-6 , \"Au\" ); s : AddLayer ( \"GoldGratingBottom\" , 5e-6 , \"Au\" ); s : SetLayerPatternGrating ( \"GoldGratingBottom\" , \"Vacuum\" , 0.5e-6 , 0.2e-6 ); s : AddLayer ( \"VacGap\" , 1e-6 , \"Vacuum\" ); s : AddLayerCopy ( \"GoldGratingTop\" , \"GoldGratingBottom\" ); s : AddLayerCopy ( \"GoldSubstrateTop\" , \"GoldSubstrateBottom\" ); s : AddLayerCopy ( \"TopAir\" , \"BottomAir\" ); s : SetSourceLayer ( \"GoldSubstrateBottom\" ); s : SetSourceLayer ( \"GoldGratingBottom\" ); s : SetProbeLayer ( \"VacGap\" ); s : OutputSysInfo (); s : OptPrintIntermediate (); s : SetThread ( 4 ); s : SetNumOfG ( 101 ); s : SetKxIntegralSym ( 500 ); s : SetKyIntegralSym ( 200 , 5 ); s : InitSimulation (); s : IntegrateKxKy (); --print(string.format(\"%e\", s:GetPhiAtKxKy(1, 0, 0))); phi = s : GetPhi (); omega = s : GetOmega (); for i = 1 , s : GetNumOfOmega (), 1 do print ( string.format ( \"%e\" , omega [ i ]) .. \" \\t \" .. string.format ( \"%e\" , phi [ i ])); end The curve produced by this code is The corresponding Python version is from MESH import SimulationGrating s = SimulationGrating () s . SetLattice ( 1e-6 ) s . AddMaterial ( \"Au\" , \"fullGold.txt\" ) s . AddMaterial ( \"Vacuum\" , \"fullVacuum.txt\" ) s . AddLayer ( \"BottomAir\" , 0 , \"Vacuum\" ) s . AddLayer ( \"GoldSubstrateBottom\" , 0.5e-6 , \"Au\" ) s . AddLayer ( \"GoldGratingBottom\" , 5e-6 , \"Au\" ) s . SetLayerPatternGrating ( \"GoldGratingBottom\" , \"Vacuum\" , 0.5e-6 , 0.2e-6 ) s . AddLayer ( \"VacGap\" , 1e-6 , \"Vacuum\" ) s . AddLayerCopy ( \"GoldGratingTop\" , \"GoldGratingBottom\" ) s . AddLayerCopy ( \"GoldSubstrateTop\" , \"GoldSubstrateBottom\" ) s . AddLayerCopy ( \"TopAir\" , \"BottomAir\" ) s . SetSourceLayer ( \"GoldSubstrateBottom\" ) s . SetSourceLayer ( \"GoldGratingBottom\" ) s . SetProbeLayer ( \"VacGap\" ) s . OutputSysInfo () s . OptPrintIntermediate () s . SetThread ( 4 ) s . SetNumOfG ( 101 ) s . SetKxIntegralSym ( 500 ) s . SetKyIntegralSym ( 200 , 5 ) s . InitSimulation () s . IntegrateKxKy ()","title":"Two Gratings Near-field"},{"location":"Examples/iterate/","text":"This file is similar to the Two Planes Near-field example, except for a loop over the vacuum gap separations. s = SimulationPlanar . new () s : AddMaterial ( \"GaAs\" , \"GaAs.txt\" ); s : AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ); s : AddMaterial ( \"PEC\" , \"PEC.txt\" ); s : AddLayer ( \"PECBottom\" , 0 , \"PEC\" ); s : AddLayer ( \"GaAsBottom\" , 1e-6 , \"GaAs\" ); s : AddLayer ( \"VacGap\" , 1e-8 , \"Vacuum\" ); s : AddLayerCopy ( \"GaAsTop\" , \"GaAsBottom\" ); s : AddLayerCopy ( \"PECTop\" , \"PECBottom\" ); s : SetSourceLayer ( \"GaAsBottom\" ); s : SetProbeLayer ( \"VacGap\" ); s : OptUseQuadgk (); s : SetThread ( 4 ); s : SetKParallelIntegral ( 500 ); for i = 10 , 100 , 10 do s : SetLayerThickness ( \"VacGap\" , i * 1e-9 ); s : InitSimulation (); s : IntegrateKParallel (); phi = s : GetPhi (); omega = s : GetOmega (); for j = 1 , s : GetNumOfOmega (), 1 do print ( string.format ( \"%e\" , omega [ j ]) .. \" \\t \" .. string.format ( \"%e\" , phi [ j ])); end end One can use the same way described here in one's own simulation for a scan of thickness of layers. The corresponding Python version is from MESH import SimulationPlanar s = SimulationPlanar () s . AddMaterial ( \"GaAs\" , \"GaAs.txt\" ) s . AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ) s . AddMaterial ( \"PEC\" , \"PEC.txt\" ) s . AddLayer ( \"PECBottom\" , 0 , \"PEC\" ) s . AddLayer ( \"GaAsBottom\" , 1e-6 , \"GaAs\" ) s . AddLayer ( \"VacGap\" , 1e-8 , \"Vacuum\" ) s . AddLayerCopy ( \"GaAsTop\" , \"GaAsBottom\" ) s . AddLayerCopy ( \"PECTop\" , \"PECBottom\" ) s . SetSourceLayer ( \"GaAsBottom\" ) s . SetProbeLayer ( \"VacGap\" ) s . OptUseQuadgk () s . SetThread ( 4 ) s . SetKParallelIntegral ( 500 ) for i in range ( 10 , 110 , 10 ): s . SetLayerThickness ( \"VacGap\" , i * 1e-9 ) s . InitSimulation () s . IntegrateKParallel ()","title":"Iterate Over Gaps Near-field"},{"location":"Examples/mixedNearField/","text":"The following is an example with a mixed pattern on one layer. The layer SiTop has two patterns: (1) a rectangle patten centered at (250 nm, 250 nm) with widths (300 nm, 300 nm), and (2) a circle pattern centered at (750 nm, 750 nm) with radius 200 nm. Note that MESH has a contraint that patterns cannot interleave with each other. s = SimulationPattern . new (); s : SetLattice ( 1e-6 , 1e-6 , 90 ); s : SetNumOfG ( 441 ); s : AddMaterial ( \"Si\" , \"Si.txt\" ); s : AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ); s : AddLayer ( \"SiBottom\" , 0 , \"Si\" ); s : AddLayer ( \"VacGap\" , 1e-7 , \"Vacuum\" ); s : AddLayer ( \"SiTop\" , 0 , \"Si\" ); s : SetLayerPatternRectangle ( \"SiTop\" , \"Vacuum\" , { 2.5e-7 , 2.5e-7 }, 0 , { 3e-7 , 3e-7 }); s : SetLayerPatternCircle ( \"SiTop\" , \"Vacuum\" , { 7.5e-7 , 7.5e-7 }, 2e-7 ); s : SetSourceLayer ( \"SiBottom\" ); s : SetProbeLayer ( \"VacGap\" ); s : OutputSysInfo (); s : OptPrintIntermediate (); s : SetKxIntegral ( 100 ); s : SetKyIntegral ( 100 ); s : InitSimulation (); s : IntegrateKxKy (); The result is","title":"Mixed Patterns Near-field"},{"location":"Examples/planeFarField/","text":"This is a simple example calculating far-field radiation from a 1~\\mu m thick GaAs slab to vacuum. Here one can set the upper bound of k_{\\parallel} integration to 1 because it is far field. s = SimulationPlanar . new () s : SetThread ( 4 ); s : AddMaterial ( \"GaAs\" , \"GaAs.txt\" ); s : AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ); s : AddMaterial ( \"PEC\" , \"PEC.txt\" ); s : AddLayer ( \"PECLayer\" , 0 , \"PEC\" ); s : AddLayer ( \"GaAsLayer\" , 1e-6 , \"GaAs\" ); s : AddLayer ( \"VacuumLayer\" , 0 , \"Vacuum\" ); s : SetSourceLayer ( \"GaAsLayer\" ); s : SetProbeLayer ( \"VacuumLayer\" ); s : OptUseQuadgk (); s : SetKParallelIntegral ( 1 ); s : InitSimulation (); s : IntegrateKParallel (); phi = s : GetPhi (); omega = s : GetOmega (); for i = 1 , s : GetNumOfOmega (), 1 do print ( string.format ( \"%e\" , omega [ i ]) .. \" \\t \" .. string.format ( \"%e\" , phi [ i ])); end The Python version of this example is from MESH import SimulationPlanar s = SimulationPlanar () s . AddMaterial ( material_name = 'GaAs' , file_name = 'GaAs.txt' ) s . AddMaterial ( material_name = 'Vacuum' , file_name = 'Vacuum.txt' ) s . AddMaterial ( material_name = 'PEC' , file_name = 'PEC.txt' ) s . AddLayer ( layer_name = 'PECLayer' , thickness = 0 , material_name = 'PEC' ) s . AddLayer ( layer_name = 'GaAsLayer' , thickness = 1e-6 , material_name = 'GaAs' ) s . AddLayer ( layer_name = 'VacuumLayer' , thickness = 0 , material_name = 'Vacuum' ) s . SetSourceLayer ( layer_name = 'GaAsLayer' ) s . SetProbeLayer ( layer_name = 'VacuumLayer' ) s . OptUseQuadgk () s . InitSimulation () s . SetKParallelIntegral ( 1 ); s . IntegrateKParallel () phi = s . GetPhi () omega = s . GetOmega () for i in range ( s . GetNumOfOmega ()): print omega [ i ], ' \\t ' , phi [ i ]","title":"Single Plane Far-field"},{"location":"Examples/planeNearField/","text":"This is the complete code for the tutorial example s = SimulationPlanar . new () s : AddMaterial ( \"GaAs\" , \"GaAs.txt\" ) s : AddMaterial ( \"PEC\" , \"PEC.txt\" ) s : AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ) s : AddLayer ( \"PECBottom\" , 0 , \"PEC\" ); s : AddLayer ( \"GaAsBottom\" , 1e-6 , \"GaAs\" ); s : AddLayer ( \"VacGap\" , 1e-8 , \"Vacuum\" ); s : AddLayerCopy ( \"GaAsTop\" , \"GaAsBottom\" ); s : AddLayerCopy ( \"PECTop\" , \"PECBottom\" ); s : SetSourceLayer ( \"GaAsBottom\" ); s : SetProbeLayer ( \"VacGap\" ); s : OptUseQuadgk (); s : SetKParallelIntegral ( 10 ); s : SetThread ( 4 ); s : InitSimulation (); s : IntegrateKParallel (); phi = s : GetPhi (); omega = s : GetOmega (); for i = 1 , s : GetNumOfOmega (), 1 do print ( string.format ( \"%e\" , omega [ i ]) .. \" \\t \" .. string.format ( \"%e\" , phi [ i ])); end This code can be run by: mesh main.lua > output.txt and the results will be contained in the output.txt file. The python version of this is from MESH import SimulationPlanar s = SimulationPlanar () s . AddMaterial ( material_name = 'GaAs' , file_name = 'GaAs.txt' ) s . AddMaterial ( material_name = 'Vacuum' , file_name = 'Vacuum.txt' ) s . AddMaterial ( material_name = 'PEC' , file_name = 'PEC.txt' ) s . AddLayer ( layer_name = 'PECBottom' , thickness = 0 , material_name = 'PEC' ) s . AddLayer ( layer_name = 'GaAsBottom' , thickness = 1e-6 , material_name = 'GaAs' ) s . AddLayer ( layer_name = 'VacGap' , thickness = 1e-8 , material_name = 'Vacuum' ) s . AddLayerCopy ( layer_name = 'GaAsTop' , copy_layer_name = 'GaAsBottom' ) s . AddLayerCopy ( layer_name = 'PECTop' , copy_layer_name = 'PECBottom' ) s . SetSourceLayer ( layer_name = 'GaAsBottom' ) s . SetProbeLayer ( layer_name = 'VacGap' ) s . OptUseQuadgk () s . SetKParallelIntegral ( integral_end = 10 ) s . SetThread ( num_thread = 4 ) s . InitSimulation () s . IntegrateKParallel () phi = s . GetPhi () omega = s . GetOmega () for i in range ( s . GetNumOfOmega ()): print omega [ i ], ' \\t ' , phi [ i ]","title":"Two Planes Near-field"},{"location":"Examples/rectangleNearField/","text":"This is an example for Fig.2 (b) black curve in arXiv:1701.02986 . constants = Constants (); function thetaDerivative ( omega , T ) local theta = constants . h_bar * omega / ( math.exp ( constants . h_bar * omega / constants . k_B / T ) - 1 ); return math.pow ( theta , 2 ) * math.exp ( constants . h_bar * omega / constants . k_B / T ) / constants . k_B / math.pow ( T , 2 ); end f = 0.98 ; width = math.sqrt ( f * 50e-9 * 50e-9 ); s = SimulationPattern . new (); s : SetLattice ( 50e-9 , 50e-9 , 90 ); s : SetNumOfG ( 440 ); s : AddMaterial ( \"Si\" , \"Si.txt\" ); s : AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ); s : AddLayer ( \"SiBottom\" , 0 , \"Si\" ); s : SetLayerPatternRectangle ( \"SiBottom\" , \"Vacuum\" , { 25e-9 , 25e-9 }, 0 , { width , width }); s : AddLayer ( \"VacGap\" , 20e-9 , \"Vacuum\" ); s : AddLayerCopy ( \"SiTop\" , \"SiBottom\" ); s : SetSourceLayer ( \"SiBottom\" ); s : SetProbeLayer ( \"VacGap\" ); s : OutputSysInfo (); s : OptPrintIntermediate (); s : SetKxIntegralSym ( 50 ); s : SetKyIntegralSym ( 50 ); s : InitSimulation (); s : IntegrateKxKy (); phi = s : GetPhi (); omega = s : GetOmega (); for i = 1 , s : GetNumOfOmega (), 1 do print ( string.format ( \"%e\" , omega [ i ]) .. \" \\t \" .. string.format ( \"%e\" , phi [ i ])); end The results is shown below The Python version of this example is from MESH import SimulationPattern , Constants import math consts = Constants () def thetaDerivative ( omega , T ): theta = consts [ 'h_bar' ] * omega / ( math . exp ( consts [ 'h_bar' ] * omega / consts [ 'k_B' ] / T ) - 1 ) return theta ** 2 * math . exp ( consts [ 'h_bar' ] * omega / consts [ 'k_B' ] / T ) / consts [ 'k_B' ] / T ** 2 f = 0.98 width = math . sqrt ( f * 50e-9 * 50e-9 ) s = SimulationPattern () s . SetLattice ( 50e-9 , 50e-9 , 90 ) s . SetNumOfG ( 440 ) s . AddMaterial ( \"Si\" , \"Si.txt\" ) s . AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ) s . AddLayer ( \"SiBottom\" , 0 , \"Si\" ) s . SetLayerPatternRectangle ( \"SiBottom\" , \"Vacuum\" , ( 25e-9 , 25e-9 ), 0 , ( width , width )) s . AddLayer ( \"VacGap\" , 20e-9 , \"Vacuum\" ) s . AddLayerCopy ( \"SiTop\" , \"SiBottom\" ) s . SetSourceLayer ( \"SiBottom\" ) s . SetProbeLayer ( \"VacGap\" ) s . OutputSysInfo () s . OptPrintIntermediate () s . SetKxIntegralSym ( 20 , 60 ) s . SetKyIntegralSym ( 20 , 60 ) s . InitSimulation () s . IntegrateKxKy ()","title":"Two Rectangle Patterns Near-field"},{"location":"Examples/tutorial/","text":"This is an detailed tutorial on the near-field heat transfer between two GaAs slabs backed with PEC. 0. Initialize simulation object \u00b6 First, to initialize the planar simulation, one should do s = SimulationPlanar . new () 1. Read input material files \u00b6 First, one should add materials to the system, and the materials are initialized by the input files. s : AddMaterial ( \"GaAs\" , \"GaAs.txt\" ) s : AddMaterial ( \"PEC\" , \"PEC.txt\" ) s : AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ) Here we initialize three materials GaAs , PEC and Vacuum , and their dielectric constants are contained in the files GaAs.txt , PEC.txt and Vacuum.txt , respectively. Here is a glance at the top few lines of GaAs.txt file: 2.126978e+15 1.306099e+01 1.228760e-02 2.131253e+15 1.307147e+01 2.845717e-02 2.135527e+15 1.308195e+01 4.462674e-02 2.139802e+15 1.309243e+01 6.079631e-02 2.144077e+15 1.310291e+01 7.696587e-02 ... ... ... where the data is specified in \\omega, \\epsilon_r, \\epsilon_i fashion, separated by tab, with in total 199 rows. All material files should contain the dielectric function at the same omega values. For PEC, one needs to use a very large \\epsilon value for it be to reflective, and Vacuum needs to have a very small imaginary part (here 10^{-10} ) to maintain numerical stability. In addition, make sure that all the .txt files are the in the same directory as the .lua script. 2. Add layers to the system \u00b6 s : AddLayer ( \"PECBottom\" , 0 , \"PEC\" ); s : AddLayer ( \"GaAsBottom\" , 1e-6 , \"GaAs\" ); s : AddLayer ( \"VacGap\" , 1e-8 , \"Vacuum\" ); s : AddLayerCopy ( \"GaAsTop\" , \"GaAsBottom\" ); s : AddLayerCopy ( \"PECTop\" , \"PECBottom\" ); Here there are in total 5 layers that has been added to the system: PECBottom , GaAsBottom , VacGap , GaAsTop and PECTop . Different from S4 , here the layers are built from bottom to the top, with the bottom most and top most layers being semi-infinite (set thickness to 0 here). The following is a drawing illustrating how the layers are added to the system: 3. Set source and probe, as well as options \u00b6 s : SetSourceLayer ( \"GaAsBottom\" ); s : SetProbeLayer ( \"VacGap\" ); s : OptUseQuadgk (); s : SetKParallelIntegral ( 10 ); s : SetThread ( 4 ); In this case, since we are simulating the heat transfer between the two GaAs layers, we set the layer GaAsBottom as the source layer, and VacGap to be the probe layer where Poynting vector is measured. Here, one needs to ensure that the source layer is always below the probe layer in the system. The following figure is an illustration after the source and probe layers are set. 4. Build simulation and perform integration \u00b6 Now, with the system built up and the integral set up, one can build RCWA matrices and perform integration over k_{\\parallel} . s : InitSimulation (); s : IntegrateKParallel (); 5. Print results \u00b6 phi = s : GetPhi (); omega = s : GetOmega (); for i = 1 , s : GetNumOfOmega (), 1 do print ( string.format ( \"%e\" , omega [ i ]) .. \" \\t \" .. string.format ( \"%e\" , phi [ i ])); end The above is a simple way to retrieve the result and print it to the screen. One can also use Lua built-in i/o functions to output result into files. Now save this file as main.lua , and one can simply type mesh main.lua to run the simulation.","title":"Tutorial Example"},{"location":"Examples/tutorial/#0-initialize-simulation-object","text":"First, to initialize the planar simulation, one should do s = SimulationPlanar . new ()","title":"0. Initialize simulation object"},{"location":"Examples/tutorial/#1-read-input-material-files","text":"First, one should add materials to the system, and the materials are initialized by the input files. s : AddMaterial ( \"GaAs\" , \"GaAs.txt\" ) s : AddMaterial ( \"PEC\" , \"PEC.txt\" ) s : AddMaterial ( \"Vacuum\" , \"Vacuum.txt\" ) Here we initialize three materials GaAs , PEC and Vacuum , and their dielectric constants are contained in the files GaAs.txt , PEC.txt and Vacuum.txt , respectively. Here is a glance at the top few lines of GaAs.txt file: 2.126978e+15 1.306099e+01 1.228760e-02 2.131253e+15 1.307147e+01 2.845717e-02 2.135527e+15 1.308195e+01 4.462674e-02 2.139802e+15 1.309243e+01 6.079631e-02 2.144077e+15 1.310291e+01 7.696587e-02 ... ... ... where the data is specified in \\omega, \\epsilon_r, \\epsilon_i fashion, separated by tab, with in total 199 rows. All material files should contain the dielectric function at the same omega values. For PEC, one needs to use a very large \\epsilon value for it be to reflective, and Vacuum needs to have a very small imaginary part (here 10^{-10} ) to maintain numerical stability. In addition, make sure that all the .txt files are the in the same directory as the .lua script.","title":"1. Read input material files"},{"location":"Examples/tutorial/#2-add-layers-to-the-system","text":"s : AddLayer ( \"PECBottom\" , 0 , \"PEC\" ); s : AddLayer ( \"GaAsBottom\" , 1e-6 , \"GaAs\" ); s : AddLayer ( \"VacGap\" , 1e-8 , \"Vacuum\" ); s : AddLayerCopy ( \"GaAsTop\" , \"GaAsBottom\" ); s : AddLayerCopy ( \"PECTop\" , \"PECBottom\" ); Here there are in total 5 layers that has been added to the system: PECBottom , GaAsBottom , VacGap , GaAsTop and PECTop . Different from S4 , here the layers are built from bottom to the top, with the bottom most and top most layers being semi-infinite (set thickness to 0 here). The following is a drawing illustrating how the layers are added to the system:","title":"2. Add layers to the system"},{"location":"Examples/tutorial/#3-set-source-and-probe-as-well-as-options","text":"s : SetSourceLayer ( \"GaAsBottom\" ); s : SetProbeLayer ( \"VacGap\" ); s : OptUseQuadgk (); s : SetKParallelIntegral ( 10 ); s : SetThread ( 4 ); In this case, since we are simulating the heat transfer between the two GaAs layers, we set the layer GaAsBottom as the source layer, and VacGap to be the probe layer where Poynting vector is measured. Here, one needs to ensure that the source layer is always below the probe layer in the system. The following figure is an illustration after the source and probe layers are set.","title":"3. Set source and probe, as well as options"},{"location":"Examples/tutorial/#4-build-simulation-and-perform-integration","text":"Now, with the system built up and the integral set up, one can build RCWA matrices and perform integration over k_{\\parallel} . s : InitSimulation (); s : IntegrateKParallel ();","title":"4. Build simulation and perform integration"},{"location":"Examples/tutorial/#5-print-results","text":"phi = s : GetPhi (); omega = s : GetOmega (); for i = 1 , s : GetNumOfOmega (), 1 do print ( string.format ( \"%e\" , omega [ i ]) .. \" \\t \" .. string.format ( \"%e\" , phi [ i ])); end The above is a simple way to retrieve the result and print it to the screen. One can also use Lua built-in i/o functions to output result into files. Now save this file as main.lua , and one can simply type mesh main.lua to run the simulation.","title":"5. Print results"},{"location":"LuaAPI/baseClass/","text":"MESH is written in an inheritance manner, so most of the functions in the base class can be directly accessed by subclasses. Usage of MESH involves writing a Lua script to call into various parts of MESH. Here we describe all of the MESH base class functions that can be called within the Lua environment. For which functions can be called for a given geometry, please read the pages SimulationPlanar , SimulationGrating and SimulationPattern for the geometries you are simulating. Note The base class is just a wrapper for most of the functions, but it cannot be initiated in a Lua script. The only instances that can be initiated are the classes corresponding to different dimensions. AddMaterial ( material name , input file ) Arguments: material name: [string], the name of the material added to the simulation. Such name is unique and if there already exists a material with the same name, an error message will be printed out. input file: [string], a file that contains the dielectric properties of the corresponding material. For scalar dielectric, the input file should be formatted as a list of omega eps_r eps_i For diagonal dielectric, the format is a list of omega eps_xx_r eps_xx_i eps_yy_r eps_yy_i eps_zz_r eps_zz_i For tensor dielectric, the format is a list of omega eps_xx_r eps_xx_i eps_xy_r eps_xy_i eps_yx_r eps_yx_i eps_yy_r eps_yy_i eps_zz_r eps_zz_i Output: None Note: The omega needs to be aligned for all the materials in the simulation. AddMaterial ( material name , omega , epsilon ) Arguments: material name: [string], the name of the material added to the simulation. Such name is unique and if there already exists a material with the same name, an error message will be printed out. omega: [table], all the omega values epsilon: [nested table], all the epsilon values Output: None Note: The omega needs to be aligned for all the materials in the simulation. SetMaterial ( material name , new epsilon ) Arguments: material name: [string], the name of the material whose epsilon will be changed. This material should already exist in the simulation (by AddMaterial ), otherwise an error will be printed out. new epsilon: [nested table], the length equals the number of omega, and per row is the epsilon values with the same format as the input of AddMaterial function. i.e. for scalar case the length will be 2 , for diagonal case the length is 6 and for tensor case the length is 10 . Output: None AddLayer ( layer name , thickness , material name ) Arguments: layer name: [string], the name of the layer. Similarly, the names for layers are unique, and if such name already exists in the simulation, an error message will be printed out. thickness: [double], the thickness of the new layer in SI unit. material name: [string], the material that is used as the background of the layer. This material should already exist in the simulation (by AddMaterial ), otherwise an error message will be printed out. Output: None Note: this new added layer will be placed on top of all the previous layers. SetLayer ( layer name , thickness , material name ) Arguments: layer name: [string], the layer whose thickness and background will be changed. Such layer needs to already exist in the simulation, otherwise an error message will be printed out. thickness: [double], the new thickness of the layer. material name: [string], the material for the background of the layer. If such material does not exist, an error message will be printed out. Output: None SetLayerThickness ( layer name , thickness ) Arguments: layer name: [string], the layer whose thickness will be changed. Such layer needs to already exist in the simulation, otherwise an error message will be printed out. thickness: [double], the new thickness of the layer. Output: None AddLayerCopy ( new layer name , original layer name ) Arguments: new layer name: [string], the new layer that is copied from the original layer. Such name cannot already exist in the simulation, otherwise an error message will be printed out. original layer name: [string], the original layer from whom everything is copied. If this layer does not exist in the simulation, an error will be printed out. Output: None Note: this function only copies the structure information, for example any pattern of the original layer, but does not copy any thermal information. For example, even the original layer is set as a source, the copied layer is still not a source. In addition, this new added layer will be placed on top of all the previous layers. DeleteLayer ( layer name ) Arguments: layer name: [string], the name of the layer that will be deleted. Such layer should already be in the system, otherwise an error will be printed out. Output: None SetNumOfG ( nG ) Arguments: nG: [int], the number of total Fourier components in both directions. Note this nG might not be the true nG used in the simulation. Output: None SetSourceLayer ( layer name ) Arguments: layer name: [string], the name of the layer that is designated as the source layer. Such layer should already exist in the system, otherwise an error will be printed out. Output: None Note: a system can have more than 1 source layers. SetProbeLayer ( layer name ) Arguments: layer name: [string], the name of the layer that is designated as the probe layer of the flux. Such layer should already exist in the system, otherwise an error will be printed out. Output: None Note: a system can have only one probe layer. Setting another layer as the probe layer will overwrite the previous one. In addition, the probe layer should be above all the source layers in the real geometry. SetProbeLayerZCoordinate ( target_z ) Arguments: target_z: [double], the zth coordinate in the target layer where the Poynting flux is evaluated. By default this value is the thickness of the target layer Output: None SetThread ( nthread ) Arguments: nthreads: [int], number of threads used in OpenMP. Output: None Note: this function only works in an OpenMP setup. SetKxIntegral ( points , end ) Arguments: points: [int], number of points in the integration. end: [double, optional for grating and pattern geometries], the end of the integral over k_x . This end should be a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing \\int_{-\\text{end}\\cdot \\omega/c}^{\\text{end}\\cdot \\omega/c}dk_x where the integral is evaluated as a summation of points points. In the case when end is not given, the lower and upper bounds of the integral will be \\pm |G_1|/2 . where G_1 is the length of the reciprocal lattice with component in x direction. See the following figure: SetKyIntegral ( points , end ) Arguments: points: [int], number of points in the integration. end: [double, optional for pattern geometries], the end of the integral over k_y . This end should be a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing \\int_{-\\text{end}\\cdot \\omega/c}^{\\text{end}\\cdot \\omega/c}dk_y where the integral is evaluated as a summation of points points. In the case when end is not given, the lower and upper bounds of the integral will be \\pm |G_2|/2 , where G_2 is the length of the reciprocal lattice along y direction SetKxIntegralSym ( points , end ) Arguments: points: [int], number of points in the integration. end: [double, optional for grating and pattern geometries], the end of the integral over k_x . This end should be a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing 2\\times \\int_{0}^{\\text{end}\\cdot \\omega/c}dk_x where the integral is evaluated as a summation of points points. In the case when end is not given, the upper bound of the integral will be |G_1|/2 . SetKyIntegralSym ( points , end ) Arguments: points: [int], number of points in the integration. end: [double, optional for pattern geometries], the end of the integral over k_y . This end should be a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing 2\\times \\int_{0}^{\\text{end}\\cdot \\omega/c}dk_y where the integral is evaluated as a summation of points points. In the case when end is not given, the upper bound of the integral will be |G_2|/2 . InitSimulation () Arguments: None Note: this function builds up the structure of the system. IntegrateKxKy () Arguments: None Output: None Note: this function integrates over k_x and k_y based on the integral properties set by the user. So the function can only be called after the k_x and k_y integrals are configured, and the system is initialized. IntegrateKxKyMPI ( rank , size ) Arguments: rank: [int], the rank of the thread. size: [int], the total size of the MPI run. Output: None Note: this function can only be called during MPI. For an example of a funtion call, please refer to MPI example . GetNumOfOmega () Arguments: None Output: [int], the number of total omega points computed in the simulation. GetPhi () Arguments: None Output: [table of double], the \\Phi(\\omega) values obtained from the simulation. Note: can only be called after k_x and k_y are integrated. GetOmega () Arguments: None Output: [table of double], the omega values computed in the simulation. GetEpsilon ( omega index , { x , y , z }) Arguments: omega index: [int], the index of the omega value where \\epsilon is evaluated. To be consistent with Lua, this index starts from 1 . {x, y, z}: [double table], the real space position where the index is evaluated, in SI unit Output: value of epsilon with length 10 , in the form of eps_xx_r, eps_xx_i, eps_xy_r, eps_xy_i, eps_yx_r, eps_yx_i,\u3000eps_yy_r, eps_yy_i, eps_zz_r, eps_zz_i These are computed by reconstruction of the Fourier series, so won't be the same as the exact dielectric function. GetPhiAtKxKy ( omega index , kx , ky ) Arguments: omega index: [int], the index of the omega value where \\Phi(\\omega[\\text{index}], k_x, k_y) is evaluated. To be consistent with Lua, this index starts from 1 . kx: [double], the k_x value where \\Phi(\\omega[\\text{index}], k_x, k_y) is evaluated. It is a normalized value by \\omega[\\text{index}]/c . ky: [double], the k_y value where \\Phi(\\omega[\\text{index}], k_x, k_y) is evaluated. It is a normalized value by \\omega[\\text{index}]/c . Output: [double], the value of \\Phi(\\omega, k_x, k_y) . GetNumOfG () Arguments: None Output: number of G. If function InitSimulation has been called, then this function returns the true nG used in the simulation, otherwise return the user input nG. OutputSysInfo () Arguments: None Output: None Note: the function prints out a system description to screen. OutputLayerPatternRealization ( omega index , name , Nu , Nv , filename ) Arguments: omega index: [int], the index of the omega value that the dielectric is evaluated. To be consistent with Lua, this index starts from 1 . name: [string], the name of the layer. Nu: [int], number of points in x direction in one periodicity. Nv: [int], number of points in y direction in one periodicity. filename: [string], optional. If not given, then the epsilon values will be printed to standard output. Output: None Note: the epsilon format will be the same as the function GetEpsilon along with the spacial coordinates. Also, MESH provides some options for printing intermediate information and methods for Fourier transform of the dielectric. OptOnlyComputeTE () Arguments: None Output: None Note: with this function, the package only computes flux contributed from TE mode. OptOnlyComputeTM () Arguments: None Output: None Note: with this function, the package only computes flux contributed from TM mode. OptPrintIntermediate ( output_flag ) Arguments: output_flag [string, optional], the output file suffix. Output: None Note: this function prints intermediate \\Phi(\\omega, k_x, k_y) to file when function IntegrateKxKy() or IntegrateKxKyMPI(rank, size) is called. The output format is a list of \" \\omega k_x k_y \\Phi(\\omega, k_x, k_y) \", where k_x and k_y are values normalized to \\omega/c . OptSetLatticeTruncation ( truncation ) Arguments: truncation: [string], the truncation method for the reciprocal lattice. Should be one of \"Circular\" or \"Parallelogramic\". Output: None MESH provides class for linear interpolating data points. In Lua, the class can be initiated using interpolator = Interpolator . new ( x_vals , y_vals ) Arguments: x_vals: [table], all the x values y_vals: [nested table], all the y values, should be two dimensional. Output: None At a certain point x , the interpolated y can be retrieved by interpolator : Get ( x ) Arguments: x: [double], the point where the interpolation is performned Output: a table of y values at x MESH also provides physics constants to facilitate computation. The constant object can be initiated by constant = Constants () The supported constants are (all in SI unit) constant.pi: the value of \\pi . constant.k_B: the value of k_B . constant.eps_0: the value of \\epsilon_0 . constant.mu_0: the value of \\mu_0 . constant.m_e: the value of m_e , i.e. the mass of an electron. constant.eV: electron volt in Joules. constant.h: the value of Planck's constant. constant.h_bar: the value of the reduced Planck's constant. constant.c_0: the speed of light. constant.q: the value of q , i.e. magnitude of electron charge. constant.sigma: the value of \\sigma , i.e. Stefan-Boltzmann constant.","title":"Base Class"},{"location":"LuaAPI/grating/","text":"The SimulationGrating class can be initiated in Lua script by s = SimulationGrating . new () Note The following functions are added and specific to SimulationGrating object. SetLattice ( p1 ) Arguments: p1: [double], the periodicity in x direction in SI unit Output: None SetLayerPatternGrating ( layer name , material name , center , width ) Arguments: layer name: [string], the layer that this grating will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the grating. Such material should already exist in the simulation, otherwise an error message will be printed out. center: [double], the center of the grating in SI unit. width: [double], the width of the grating in SI unit. Output: None","title":"SimulationGrating"},{"location":"LuaAPI/pattern/","text":"The SimulationPattern class can be initiated in Lua script by s = SimulationPattern . new () All of the function provided in base class can be used. Note The following functions are added and specific to SimulationPattern object. SetLattice ( xLen , yLen , angle ) Arguments: xLen: [double], the length of the periodicity in x direction in SI unit. yLen: [double], the length of the periodicity in the other direction in SI unit. angle: the angle between the two lattice axises, in degree. Output: None Note: MESH handles the case when one of the real space lattice is aligned with x axis (with length xLen ), and the other axis should be in the upper plane. The angle between the two axises are specified by angle . See the following figure: GetReciprocalLattice () Arguments: None Outputs: {{ x_1 , y_1 }, { x_2 , y_2 }}. Two tables of the reciprocal lattices in SI unit. SetLayerPatternRectangle ( layer name , material name , { centerx , centery }, angle , { widthx , widthy }) Arguments: layer name: [string], the layer that this rectangle pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the rectangle pattern. Such material should already exist in the simulation, otherwise an error message will be printed out. angle: the rotated angle with respect to the positive x direction in a counterclockwise manner, in degree. {centerx, centery}: [double table], the centers of the rectangle pattern in x and y direction, respectively, in SI unit. {widthx, widthy}: [double table], the widths of the rectangle pattern in x and y direction, respectively, in SI unit. Output: None SetLayerPatternCircle ( layer name , material name , { centerx , centery }, radius ) Arguments: layer name: [string], the layer that this circle pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the circle pattern. Such material should already exist in the simulation, otherwise an error message will be printed out. {centerx, centery}: [double table], the centers of the circle pattern in x and y direction, respectively, in SI unit. radius: [double], the radius of the circle pattern in SI unit. Output: None SetLayerPatternEllipse ( layer name , material name , { centerx , centery }, angle , { a , b }) Arguments: layer name: [string], the layer that this ellipse pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the ellipse pattern. Such material should already exist in the simulation, otherwise an error message will be printed out. angle: the rotated angle with respect to the positive x direction in a counterclockwise manner, in degree. {centerx, centery}: [double table], the centers of the ellipse pattern in x and y direction, respectively, in SI unit. {a, b}: [double], the half widths the ellipse pattern in SI unit. Output: None Note: the ellipse with angle =0 is written as: \\frac{(x-x_c)^2}{a^2}+\\frac{(y-y_c)^2}{b^2}=1 SetLayerPatternPolygon ( layer name , material name , { centerx , centery }, angle , { { v1_x , v2_x }, ..., { vn_x , vn_y } }) Arguments: layer name: [string], the layer that this polygon pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the polygon pattern. Such material should already exist in the simulation, otherwise an error message will be printed out. {centerx, centery}: [double table], the centers of the polygon pattern in x and y direction, respectively, in SI unit. angle: the rotated angle with respect to the positive x direction in a counterclockwise manner, in degree. { {v1_x, v2_x}, ..., {vn_x, vn_y} }: [nested double table], coordinates of the vertices relative to the center in SI unit. Output: None","title":"SimulationPattern"},{"location":"LuaAPI/planar/","text":"The SimulationPlanar class can be initiated in Lua script by s = SimulationPlanar . new () Most of the function provided in base class can be used except for the following changes. Failure The following function are unavailable and cannot be called for a SimulationPlanar object. OptPrintIntermediate () Note The following functions are added and specific to SimulationPlanar object. SetKParallel ( end ) Arguments: end: [double], the end of the k_{\\parallel} integral. It is a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing \\int_{0}^{\\text{end}\\cdot\\omega/c}dk_{\\parallel} where the integral is evaluated either using Gauss-legendre methdod or Gauss-kronrod adaptive method. GetPhiAtKParallel ( omega index , k parallel value ) Arguments: omega index: [int], the index of omega where \\Phi(\\omega[\\text{index}], k_{\\parallel}) is evaluated. To be consistent with Lua, this index starts from 1 . k parallel: [double], the k_{\\parallel} value where \\Phi(\\omega[\\text{index}], k_{\\parallel}) is evaluated. It should be a normalized value with respect to \\omega[\\text{index}]/c . Output: [double], value of \\Phi(\\omega[\\text{index}], k_{\\parallel}) . IntegrateKParallel () Arguments: None Output: None Note: before using this function, make sure the flux integral can be reduced to a k_{\\parallel} integral. In principle, the cases when all the materials possess only scalar dielectric or diagonal forms \\begin{pmatrix} \\epsilon_{1} & 0 & 0\\\\ 0 & \\epsilon_{1} & 0\\\\ 0 & 0 & \\epsilon_{2} \\end{pmatrix} can use this function. OptUseQuadgl ( degree ) Arguments: degree: [int, optional], using Gauss-legendre method in the integral and set the degree of legendre polynomial in IntegrateKParallel() . If degree is not given, it is set to be 1024 . Output: None OptUseQuadgk () Arguments: None Output: None Note: this function uses Gauss-kronrod adaptive integral algorithm in IntegrateKParallel() . The simulation will use this function if the integral option is not specified.","title":"SimulationPlanar"},{"location":"PythonAPI/baseClass/","text":"MESH is written in an inheritance manner, so most of the functions in the base class can be directly accessed by subclasses. Usage of MESH involves writing a python script to call into various parts of MESH. Here we describe all of the MESH base class functions that can be called within the python environment. For which functions can be called for a given geometry, please read the pages SimulationPlanar , SimulationGrating and SimulationPattern for the geometries you are simulating. Note The base class is just a wrapper for most of the functions, but it cannot be initiated in a python script. The only instances that can be initiated are the classes corresponding to different dimensions. AddMaterial ( material name , input file ) Arguments: material name: [string], the name of the material added to the simulation. Such name is unique and if there already exists a material with the same name, an error message will be printed out. input file: [string], a file that contains the dielectric properties of the corresponding material. For scalar dielectric, the input file should be formatted as a list of omega eps_r eps_i For diagonal dielectric, the format is a list of omega eps_xx_r eps_xx_i eps_yy_r eps_yy_i eps_zz_r eps_zz_i For tensor dielectric, the format is a list of omega eps_xx_r eps_xx_i eps_xy_r eps_xy_i eps_yx_r eps_yx_i eps_yy_r eps_yy_i eps_zz_r eps_zz_i Output: None Note: The omega needs to be aligned for all the materials in the simulation. ``lua AddMaterial(material name, omega, epsilon) * Arguments : 1. material name : [ string ], the name of the material added to the simulation . Such name is unique and if there already exists a material with the same name , an error message will be printed out . 2. omega : [ tuple ], all the omega values 3. epsilon : [ nested tuple ], all the epsilon values * Output : None * Note : The omega needs to be aligned for all the materials in the simulation . ``` python SetMaterial ( material name , new epsilon ) Arguments: material name: [string], the name of the material whose epsilon will be changed. This material should already exist in the simulation (by AddMaterial ), otherwise an error will be printed out. new epsilon: [nested tuple], the length equals the number of omega, and per row is the epsilon values with the same format as the input of AddMaterial function. i.e. for scalar case the length will be 2 , for diagonal case the length is 6 and for tensor case the length is 10 . Output: None AddLayer ( layer name , thickness , material name ) Arguments: layer name: [string], the name of the layer. Similarly, the names for layers are unique, and if such name already exists in the simulation, an error message will be printed out. thickness: [double], the thickness of the new layer in SI unit. material name: [string], the material that is used as the background of the layer. This material should already exist in the simulation (by AddMaterial ), otherwise an error message will be printed out. Output: None Note: this new added layer will be placed on top of all the previous layers. SetLayer ( layer name , thickness , material name ) Arguments: layer name: [string], the layer whose thickness and background will be changed. Such layer needs to already exist in the simulation, otherwise an error message will be printed out. thickness: [double], the new thickness of the layer. material name: [string], the material for the background of the layer. If such material does not exist, an error message will be printed out. Output: None SetLayerThickness ( layer name , thickness ) Arguments: layer name: [string], the layer whose thickness will be changed. Such layer needs to already exist in the simulation, otherwise an error message will be printed out. thickness: [double], the new thickness of the layer. Output: None AddLayerCopy ( new layer name , original layer name ) Arguments: new layer name: [string], the new layer that is copied from the original layer. Such name cannot already exist in the simulation, otherwise an error message will be printed out. original layer name: [string], the original layer from whom everything is copied. If this layer does not exist in the simulation, an error will be printed out. Output: None Note: this function only copies the structure information, for example any pattern of the original layer, but does not copy any thermal information. For example, even the original layer is set as a source, the copied layer is still not a source. In addition, this new added layer will be placed on top of all the previous layers. DeleteLayer ( layer name ) Arguments: layer name: [string], the name of the layer that will be deleted. Such layer should already be in the system, otherwise an error will be printed out. Output: None SetSourceLayer ( layer name ) Arguments: layer name: [string], the name of the layer that is designated as the source layer. Such layer should already exist in the system, otherwise an error will be printed out. Output: None Note: a system can have more than 1 source layers. SetProbeLayer ( layer name ) Arguments: layer name: [string], the name of the layer that is designated as the probe layer of the flux. Such layer should already exist in the system, otherwise an error will be printed out. Output: None Note: a system can have only one probe layer. Setting another layer as the probe layer will overwrite the previous one. In addition, the probe layer should be above all the source layers in the real geometry. SetProbeLayerZCoordinate ( target_z ) Arguments: target_z: [double], the zth coordinate in the target layer where the Poynting flux is evaluated. By default this value is the thickness of the target layer Output: None SetThread ( nthread ) Arguments: nthreads: [int], number of threads used in OpenMP. Output: None Note: this function only works in an OpenMP setup. SetKxIntegral ( points , end ) Arguments: points: [int], number of points in the integration. end: [double, optional for grating and pattern geometries], the end of the integral over k_x . This end should be a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing \\int_{-\\text{end}\\cdot \\omega/c}^{\\text{end}\\cdot \\omega/c}dk_x where the integral is evaluated as a summation of points points. In the case when end is not given, the lower and upper bounds of the integral will be \\pm |G_1|/2 . where G_1 is the length of the reciprocal lattice with component in x direction. See the following figure: SetKyIntegral ( points , end ) Arguments: points: [int], number of points in the integration. end: [double, optional for pattern geometries], the end of the integral over k_y . This end should be a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing \\int_{-\\text{end}\\cdot \\omega/c}^{\\text{end}\\cdot \\omega/c}dk_y where the integral is evaluated as a summation of points points. In the case when end is not given, the lower and upper bounds of the integral will be \\pm |G_2|/2 , where G_2 is the length of the reciprocal lattice along y direction SetKxIntegralSym ( points , end ) Arguments: points: [int], number of points in the integration. end: [double, optional for grating and pattern geometries], the end of the integral over k_x . This end should be a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing 2\\times \\int_{0}^{\\text{end}\\cdot \\omega/c}dk_x where the integral is evaluated as a summation of points points. In the case when end is not given, the upper bound of the integral will be |G_1|/2 . SetKyIntegralSym ( points , end ) Arguments: points: [int], number of points in the integration. end: [double, optional for pattern geometries], the end of the integral over k_y . This end should be a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing 2\\times \\int_{0}^{\\text{end}\\cdot \\omega/c}dk_y where the integral is evaluated as a summation of points points. In the case when end is not given, the upper bound of the integral will be |G_2|/2 . InitSimulation () Arguments: None Note: this function builds up the structure of the system. IntegrateKxKy () Arguments: None Output: None Note: this function integrates over k_x and k_y based on the integral properties set by the user. So the function can only be called after the k_x and k_y integrals are configured, and the system is initialized. IntegrateKxKyMPI ( rank , size ) Arguments: rank: [int], the rank of the thread. size: [int], the total size of the MPI run. Output: None Note: this function can only be called during MPI. For an example of a funtion call, please refer to MPI example . GetNumOfOmega () Arguments: None Output: [int], the number of total omega points computed in the simulation. GetPhi () Arguments: None Output: [tuple of double], the \\Phi(\\omega) values obtained from the simulation. Note: can only be called after k_x and k_y are integrated. GetOmega () Arguments: None Output: [tuple of double], the omega values computed in the simulation. GetEpsilon ( omega index , ( x , y , z )) Arguments: omega index: [int], the index of the omega value where \\epsilon is evaluated. To be consistent with python, this index starts from 1 . (x, y, z): [double tuple], the real space position where the index is evaluated, in SI unit Output: value of epsilon with length 10 , in the form of eps_xx_r, eps_xx_i, eps_xy_r, eps_xy_i, eps_yx_r, eps_yx_i,\u3000eps_yy_r, eps_yy_i, eps_zz_r, eps_zz_i These are computed by reconstruction of the Fourier series, so won't be the same as the exact dielectric function. GetPhiAtKxKy ( omega index , kx , ky ) Arguments: omega index: [int], the index of the omega value where \\Phi(\\omega[\\text{index}], k_x, k_y) is evaluated. To be consistent with python, this index starts from 1 . kx: [double], the k_x value where \\Phi(\\omega[\\text{index}], k_x, k_y) is evaluated. It is a normalized value by \\omega[\\text{index}]/c . ky: [double], the k_y value where \\Phi(\\omega[\\text{index}], k_x, k_y) is evaluated. It is a normalized value by \\omega[\\text{index}]/c . Output: [double], the value of \\Phi(\\omega, k_x, k_y) . OutputSysInfo () Arguments: None Output: None Note: the function prints out a system description to screen. OutputLayerPatternRealization ( omega index , name , Nu , Nv , filename ) Arguments: omega index: [int], the index of the omega value that the dielectric is evaluated. To be consistent with python, this index starts from 1 . name: [string], the name of the layer. Nu: [int], number of points in x direction in one periodicity. Nv: [int], number of points in y direction in one periodicity. filename: [string], optional. If not given, then the epsilon values will be printed to standard output. Output: None Note: the epsilon format will be the same as the function GetEpsilon along with the spacial coordinates. Also, MESH provides some options for printing intermediate information and methods for Fourier transform of the dielectric. OptOnlyComputeTE () Arguments: None Output: None Note: with this function, the package only computes flux contributed from TE mode. OptOnlyComputeTM () Arguments: None Output: None Note: with this function, the package only computes flux contributed from TM mode. OptPrintIntermediate ( output_flag ) Arguments: output_flag [string, optional], the output file suffix. Output: None Note: this function prints intermediate \\Phi(\\omega, k_x, k_y) to file when function IntegrateKxKy() or IntegrateKxKyMPI(rank, size) is called. The output format is a list of \" \\omega k_x k_y \\Phi(\\omega, k_x, k_y) \", where k_x and k_y are values normalized to \\omega/c . MESH provides class for linear interpolating data points. In Python, the class can be initiated using from MESH import Interpolator interpolator = Interpolator ( data ) Arguments: data: [nested tuples], in the form of ( ( x_1 , y_1 )...( x_n , y_n )), where y_i should also be a tuple. Output: None At a certain point x , the interpolated y can be retrieved by interpolator . Get ( x ) Arguments: x: [double], the point where the interpolation is performned Output: a tuple of y values at x MESH also provides physics constants to facilitate computation. The constant object can be initiated by from MESH import Constants constant = Constants () The supported constants are (all in SI unit) constant['pi']: the value of \\pi . constant['k_B']: the value of k_B . constant['eps_0']: the value of \\epsilon_0 . constant['mu_0']: the value of \\mu_0 . constant['m_e']: the value of m_e , i.e. the mass of an electron. constant['eV']: electron volt in Joules. constant['h']: the value of Planck's constant. constant['h_bar']: the value of the reduced Planck's constant. constant['c_0']: the speed of light. constant['q']: the value of q , i.e. magnitude of electron charge. constant['sigma']: the value of \\sigma , i.e. Stefan-Boltzmann constant.","title":"Base Class"},{"location":"PythonAPI/grating/","text":"The SimulationGrating class can be initiated in python script by from MESH import SimulationGrating s = SimulationGrating () SetNumOfG ( nG ) Arguments: nG: [int], the number of total Fourier components in both directions. Note this nG might not be the true nG used in the simulation. Output: None GetNumOfG () Arguments: None Output: number of G. If function InitSimulation has been called, then this function returns the true nG used in the simulation, otherwise return the user input nG. Note The following functions are added and specific to SimulationGrating object. SetLattice ( p1 ) Arguments: p1: [double], the periodicity in x direction in SI unit Output: None SetLayerPatternGrating ( layer name , material name , center , width ) Arguments: layer name: [string], the layer that this grating will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the grating. Such material should already exist in the simulation, otherwise an error message will be printed out. center: [double], the center of the grating in SI unit. width: [double], the width of the grating in SI unit. Output: None","title":"SimulationGrating"},{"location":"PythonAPI/pattern/","text":"The SimulationPattern class can be initiated in python script by from MESH import SimulationPattern s = SimulationPattern () All of the function provided in base class can be used. Note The following functions are added and specific to SimulationPattern object. SetNumOfG ( nG ) Arguments: nG: [int], the number of total Fourier components in both directions. Note this nG might not be the true nG used in the simulation. Output: None GetNumOfG () Arguments: None Output: number of G. If function InitSimulation has been called, then this function returns the true nG used in the simulation, otherwise return the user input nG. SetLattice ( xLen , yLen , angle ) Arguments: xLen: [double], the length of the periodicity in x direction in SI unit. yLen: [double], the length of the periodicity in the other direction in SI unit. angle: the angle between the two lattice axises, in degree. Output: None Note: MESH handles the case when one of the real space lattice is aligned with x axis (with length xLen ), and the other axis should be in the upper plane. The angle between the two axises are specified by angle . See the following figure: GetReciprocalLattice () Arguments: None Outputs: (( x_1 , y_1 ), ( x_2 , y_2 )). Two tuples of the reciprocal lattices in SI unit. OptSetLatticeTruncation ( truncation ) Arguments: truncation: [string], the truncation method for the reciprocal lattice. Should be one of \"Circular\" or \"Parallelogramic\". Output: None SetLayerPatternRectangle ( layer name , material name , ( centerx , centery ), angle , ( widthx , widthy )) Arguments: layer name: [string], the layer that this rectangle pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the rectangle pattern. Such material should already exist in the simulation, otherwise an error message will be printed out. angle: the rotated angle with respect to the positive x direction in a counterclockwise manner, in degree. (centerx, centery): [double tuple], the centers of the rectangle pattern in x and y direction, respectively, in SI unit. (widthx, widthy): [double tuple], the widths of the rectangle pattern in x and y direction, respectively, in SI unit. Output: None SetLayerPatternCircle ( layer name , material name , ( centerx , centery ), radius ) Arguments: layer name: [string], the layer that this circle pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the circle pattern. Such material should already exist in the simulation, otherwise an error message will be printed out. (centerx, centery): [double tuple], the centers of the circle pattern in x and y direction, respectively, in SI unit. radius: [double], the radius of the circle pattern in SI unit. Output: None SetLayerPatternEllipse ( layer name , material name , ( centerx , centery ), angle , ( a , b )) Arguments: layer name: [string], the layer that this ellipse pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the ellipse pattern. Such material should already exist in the simulation, otherwise an error message will be printed out. angle: the rotated angle with respect to the positive x direction in a counterclockwise manner, in degree. {centerx, centery}: [double table], the centers of the ellipse pattern in x and y direction, respectively, in SI unit. (a, b): [double], the half widths the ellipse pattern in SI unit. Output: None Note: the ellipse with angle =0 is written as: \\frac{(x-x_c)^2}{a^2}+\\frac{(y-y_c)^2}{b^2}=1 SetLayerPatternPolygon ( layer name , material name , ( centerx , centery ), angle , ( ( v1_x , v2_x ), ... , ( vn_x , vn_y ) )) Arguments: layer name: [string], the layer that this polygon pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out. material name: [string], the material used as the polygon pattern. Such material should already exist in the simulation, otherwise an error message will be printed out. (centerx, centery): [double tuple], the centers of the polygon pattern in x and y direction, respectively, in SI unit. angle: the rotated angle with respect to the positive x direction in a counterclockwise manner, in degree. ( (v1_x, v2_x), ..., (vn_x, vn_y) ): [nested double tuples], coordinates of the vertices relative to the center in SI unit. Output: None","title":"SimulationPattern"},{"location":"PythonAPI/planar/","text":"The SimulationPlanar class can be initiated in python script by from MESH import SimulationPlanar s = SimulationPlanar () Most of the function provided in base class can be used except for the following changes. Failure The following function are unavailable and cannot be called for a SimulationPlanar object. OptPrintIntermediate () Note The following functions are added and specific to SimulationPlanar object. SetKParallel ( end ) Arguments: end: [double], the end of the k_{\\parallel} integral. It is a normalized number with respect to \\omega/c . Output: None Note: this function is essentially doing \\int_{0}^{\\text{end}\\cdot\\omega/c}dk_{\\parallel} where the integral is evaluated either using Gauss-legendre methdod or Gauss-kronrod adaptive method. GetPhiAtKParallel ( omega index , k parallel value ) Arguments: omega index: [int], the index of omega where \\Phi(\\omega[\\text{index}], k_{\\parallel}) is evaluated. To be consistent with python, this index starts from 1 . k parallel: [double], the k_{\\parallel} value where \\Phi(\\omega[\\text{index}], k_{\\parallel}) is evaluated. It should be a normalized value with respect to \\omega[\\text{index}]/c . Output: [double], value of \\Phi(\\omega[\\text{index}], k_{\\parallel}) . IntegrateKParallel () Arguments: None Output: None Note: before using this function, make sure the flux integral can be reduced to a k_{\\parallel} integral. In principle, the cases when all the materials possess only scalar dielectric or diagonal forms \\begin{pmatrix} \\epsilon_{1} & 0 & 0\\\\ 0 & \\epsilon_{1} & 0\\\\ 0 & 0 & \\epsilon_{2} \\end{pmatrix} can use this function. OptUseQuadgl ( degree ) Arguments: degree: [int, optional], using Gauss-legendre method in the integral and set the degree of legendre polynomial in IntegrateKParallel() . If degree is not given, it is set to be 1024 . Output: None OptUseQuadgk () Arguments: None Output: None Note: this function uses Gauss-kronrod adaptive integral algorithm in IntegrateKParallel() . The simulation will use this function if the integral option is not specified.","title":"SimulationPlanar"}]}